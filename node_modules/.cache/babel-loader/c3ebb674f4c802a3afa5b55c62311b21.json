{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\pr0\\\\blockchain-developer-bootcamp\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _asyncToGenerator = require(\"C:/pr0/blockchain-developer-bootcamp/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _ = require('underscore');\n\nvar errors = require('web3-core-helpers').errors;\n\nvar formatters = require('web3-core-helpers').formatters;\n\nvar utils = require('web3-utils');\n\nvar promiEvent = require('web3-core-promievent');\n\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar Method = function Method(options) {\n  if (!options.call || !options.name) {\n    throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n  }\n\n  this.name = options.name;\n  this.call = options.call;\n  this.params = options.params || 0;\n  this.inputFormatter = options.inputFormatter;\n  this.outputFormatter = options.outputFormatter;\n  this.transformPayload = options.transformPayload;\n  this.extraFormatters = options.extraFormatters;\n  this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n\n  this.requestManager = options.requestManager; // reference to eth.accounts\n\n  this.accounts = options.accounts;\n  this.defaultBlock = options.defaultBlock || 'latest';\n  this.defaultAccount = options.defaultAccount || null;\n  this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n  this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n  this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n  this.defaultCommon = options.defaultCommon;\n  this.defaultChain = options.defaultChain;\n  this.defaultHardfork = options.defaultHardfork;\n  this.handleRevert = options.handleRevert;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n  this.requestManager = requestManager; // reference to eth.accounts\n\n  if (accounts) {\n    this.accounts = accounts;\n  }\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n  var func = this.buildCall();\n  func.call = this.call;\n  this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n  return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n  var func = this.buildCall();\n  func.call = this.call;\n  var name = this.name.split('.');\n\n  if (name.length > 1) {\n    obj[name[0]] = obj[name[0]] || {};\n    obj[name[0]][name[1]] = func;\n  } else {\n    obj[name[0]] = func;\n  }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\n\n\nMethod.prototype.getCall = function (args) {\n  return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\n\nMethod.prototype.extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nMethod.prototype.validateArgs = function (args) {\n  if (args.length !== this.params) {\n    throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nMethod.prototype.formatInput = function (args) {\n  var _this = this;\n\n  if (!this.inputFormatter) {\n    return args;\n  }\n\n  return this.inputFormatter.map(function (formatter, index) {\n    // bind this for defaultBlock, and defaultAccount\n    return formatter ? formatter.call(_this, args[index]) : args[index];\n  });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nMethod.prototype.formatOutput = function (result) {\n  var _this = this;\n\n  if (_.isArray(result)) {\n    return result.map(function (res) {\n      return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n    });\n  } else {\n    return this.outputFormatter && result ? this.outputFormatter(result) : result;\n  }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nMethod.prototype.toPayload = function (args) {\n  var call = this.getCall(args);\n  var callback = this.extractCallback(args);\n  var params = this.formatInput(args);\n  this.validateArgs(params);\n  var payload = {\n    method: call,\n    params: params,\n    callback: callback\n  };\n\n  if (this.transformPayload) {\n    payload = this.transformPayload(payload);\n  }\n\n  return payload;\n};\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n  var method = this,\n      promiseResolved = false,\n      canUnsubscribe = true,\n      timeoutCount = 0,\n      confirmationCount = 0,\n      intervalId = null,\n      lastBlock = null,\n      receiptJSON = '',\n      gasProvided = _.isObject(payload.params[0]) && payload.params[0].gas ? payload.params[0].gas : null,\n      isContractDeployment = _.isObject(payload.params[0]) && payload.params[0].data && payload.params[0].from && !payload.params[0].to,\n      hasBytecode = isContractDeployment && payload.params[0].data.length > 2; // add custom send Methods\n\n  var _ethereumCalls = [new Method({\n    name: 'getBlockByNumber',\n    call: 'eth_getBlockByNumber',\n    params: 2,\n    inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n      return !!val;\n    }],\n    outputFormatter: formatters.outputBlockFormatter\n  }), new Method({\n    name: 'getTransactionReceipt',\n    call: 'eth_getTransactionReceipt',\n    params: 1,\n    inputFormatter: [null],\n    outputFormatter: formatters.outputTransactionReceiptFormatter\n  }), new Method({\n    name: 'getCode',\n    call: 'eth_getCode',\n    params: 2,\n    inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n  }), new Subscriptions({\n    name: 'subscribe',\n    type: 'eth',\n    subscriptions: {\n      'newBlockHeaders': {\n        subscriptionName: 'newHeads',\n        // replace subscription with this name\n        params: 0,\n        outputFormatter: formatters.outputBlockFormatter\n      }\n    }\n  })]; // attach methods to this._ethereumCall\n\n  var _ethereumCall = {};\n\n  _.each(_ethereumCalls, function (mthd) {\n    mthd.attachToObject(_ethereumCall);\n    mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n  }); // fire \"receipt\" and confirmation events and resolve after\n\n\n  var checkConfirmation = function checkConfirmation(existingReceipt, isPolling, err, blockHeader, sub) {\n    if (!err) {\n      // create fake unsubscribe\n      if (!sub) {\n        sub = {\n          unsubscribe: function unsubscribe() {\n            clearInterval(intervalId);\n          }\n        };\n      } // if we have a valid receipt we don't need to send a request\n\n\n      return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result) // catch error from requesting receipt\n      ).catch(function (err) {\n        sub.unsubscribe();\n        promiseResolved = true;\n\n        utils._fireError({\n          message: 'Failed to check for transaction receipt:',\n          data: err\n        }, defer.eventEmitter, defer.reject);\n      }) // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n      .then( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(receipt) {\n          var block;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (!(!receipt || !receipt.blockHash)) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  throw new Error('Receipt missing or blockHash null');\n\n                case 2:\n                  // apply extra formatters\n                  if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                  } // check if confirmation listener exists\n\n\n                  if (!(defer.eventEmitter.listeners('confirmation').length > 0)) {\n                    _context.next = 24;\n                    break;\n                  }\n\n                  if (!(existingReceipt === undefined || confirmationCount !== 0)) {\n                    _context.next = 21;\n                    break;\n                  }\n\n                  if (!isPolling) {\n                    _context.next = 20;\n                    break;\n                  }\n\n                  if (!lastBlock) {\n                    _context.next = 13;\n                    break;\n                  }\n\n                  _context.next = 9;\n                  return _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n\n                case 9:\n                  block = _context.sent;\n\n                  if (block) {\n                    lastBlock = block;\n                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                  }\n\n                  _context.next = 18;\n                  break;\n\n                case 13:\n                  _context.next = 15;\n                  return _ethereumCall.getBlockByNumber(receipt.blockNumber);\n\n                case 15:\n                  block = _context.sent;\n                  lastBlock = block;\n                  defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n\n                case 18:\n                  _context.next = 21;\n                  break;\n\n                case 20:\n                  defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n\n                case 21:\n                  if (isPolling && block || !isPolling) {\n                    confirmationCount++;\n                  }\n\n                  canUnsubscribe = false;\n\n                  if (confirmationCount === method.transactionConfirmationBlocks + 1) {\n                    // add 1 so we account for conf 0\n                    sub.unsubscribe();\n                    defer.eventEmitter.removeAllListeners();\n                  }\n\n                case 24:\n                  return _context.abrupt(\"return\", receipt);\n\n                case 25:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()) // CHECK for CONTRACT DEPLOYMENT\n      .then( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(receipt) {\n          var code, deploymentSuccess;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(isContractDeployment && !promiseResolved)) {\n                    _context2.next = 19;\n                    break;\n                  }\n\n                  if (receipt.contractAddress) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  if (canUnsubscribe) {\n                    sub.unsubscribe();\n                    promiseResolved = true;\n                  }\n\n                  utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n\n                  return _context2.abrupt(\"return\");\n\n                case 5:\n                  _context2.prev = 5;\n                  _context2.next = 8;\n                  return _ethereumCall.getCode(receipt.contractAddress);\n\n                case 8:\n                  code = _context2.sent;\n                  _context2.next = 13;\n                  break;\n\n                case 11:\n                  _context2.prev = 11;\n                  _context2.t0 = _context2[\"catch\"](5);\n\n                case 13:\n                  if (code) {\n                    _context2.next = 15;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 15:\n                  // If deployment is status.true and there was a real\n                  // bytecode string, assume it was successful.\n                  deploymentSuccess = receipt.status === true && hasBytecode;\n\n                  if (deploymentSuccess || code.length > 2) {\n                    defer.eventEmitter.emit('receipt', receipt); // if contract, return instance instead of receipt\n\n                    if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                      defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                    } else {\n                      defer.resolve(receipt);\n                    } // need to remove listeners, as they aren't removed automatically when succesfull\n\n\n                    if (canUnsubscribe) {\n                      defer.eventEmitter.removeAllListeners();\n                    }\n                  } else {\n                    utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                  }\n\n                  if (canUnsubscribe) {\n                    sub.unsubscribe();\n                  }\n\n                  promiseResolved = true;\n\n                case 19:\n                  return _context2.abrupt(\"return\", receipt);\n\n                case 20:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[5, 11]]);\n        }));\n\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()) // CHECK for normal tx check for receipt only\n      .then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(receipt) {\n          var revertMessage;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (!(!isContractDeployment && !promiseResolved)) {\n                    _context3.next = 33;\n                    break;\n                  }\n\n                  if (!(!receipt.outOfGas && (!gasProvided || gasProvided !== receipt.gasUsed) && (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined'))) {\n                    _context3.next = 7;\n                    break;\n                  }\n\n                  defer.eventEmitter.emit('receipt', receipt);\n                  defer.resolve(receipt); // need to remove listeners, as they aren't removed automatically when succesfull\n\n                  if (canUnsubscribe) {\n                    defer.eventEmitter.removeAllListeners();\n                  }\n\n                  _context3.next = 31;\n                  break;\n\n                case 7:\n                  receiptJSON = JSON.stringify(receipt, null, 2);\n\n                  if (!(receipt.status === false || receipt.status === '0x0')) {\n                    _context3.next = 30;\n                    break;\n                  }\n\n                  _context3.prev = 9;\n                  revertMessage = null;\n\n                  if (!(method.handleRevert && method.call === 'eth_sendTransaction')) {\n                    _context3.next = 22;\n                    break;\n                  }\n\n                  _context3.next = 14;\n                  return method.getRevertReason(payload.params[0], receipt.blockNumber);\n\n                case 14:\n                  revertMessage = _context3.sent;\n\n                  if (!revertMessage) {\n                    _context3.next = 19;\n                    break;\n                  }\n\n                  // Only throw a revert error if a revert reason is existing\n                  utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n\n                  _context3.next = 20;\n                  break;\n\n                case 19:\n                  throw false;\n\n                case 20:\n                  _context3.next = 23;\n                  break;\n\n                case 22:\n                  throw false;\n\n                case 23:\n                  _context3.next = 28;\n                  break;\n\n                case 25:\n                  _context3.prev = 25;\n                  _context3.t0 = _context3[\"catch\"](9);\n\n                  // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                  utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n\n                case 28:\n                  _context3.next = 31;\n                  break;\n\n                case 30:\n                  // Throw OOG if status is not existing and provided gas and used gas are equal\n                  utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n\n                case 31:\n                  if (canUnsubscribe) {\n                    sub.unsubscribe();\n                  }\n\n                  promiseResolved = true;\n\n                case 33:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, null, [[9, 25]]);\n        }));\n\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()) // time out the transaction if not mined after 50 blocks\n      .catch(function () {\n        timeoutCount++; // check to see if we are http polling\n\n        if (!!isPolling) {\n          // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n          if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        } else {\n          if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n            sub.unsubscribe();\n            promiseResolved = true;\n\n            utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n          }\n        }\n      });\n    } else {\n      sub.unsubscribe();\n      promiseResolved = true;\n\n      utils._fireError({\n        message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n        data: err\n      }, defer.eventEmitter, defer.reject);\n    }\n  }; // start watching for confirmation depending on the support features of the provider\n\n\n  var startWatching = function (existingReceipt) {\n    // if provider allows PUB/SUB\n    if (_.isFunction(this.requestManager.provider.on)) {\n      _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n    } else {\n      intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n    }\n  }.bind(this); // first check if we already have a confirmed transaction\n\n\n  _ethereumCall.getTransactionReceipt(result).then(function (receipt) {\n    if (receipt && receipt.blockHash) {\n      if (defer.eventEmitter.listeners('confirmation').length > 0) {\n        // We must keep on watching for new Blocks, if a confirmation listener is present\n        startWatching(receipt);\n      }\n\n      checkConfirmation(receipt, false);\n    } else if (!promiseResolved) {\n      startWatching();\n    }\n  }).catch(function () {\n    if (!promiseResolved) startWatching();\n  });\n};\n\nvar getWallet = function getWallet(from, accounts) {\n  var wallet = null; // is index given\n\n  if (_.isNumber(from)) {\n    wallet = accounts.wallet[from]; // is account given\n  } else if (_.isObject(from) && from.address && from.privateKey) {\n    wallet = from; // search in wallet for address\n  } else {\n    wallet = accounts.wallet[from.toLowerCase()];\n  }\n\n  return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n  var method = this,\n      isSendTx = method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction',\n      // || method.call === 'personal_sendTransaction'\n  isCall = method.call === 'eth_call'; // actual send function\n\n  var send = function send() {\n    var defer = promiEvent(!isSendTx),\n        payload = method.toPayload(Array.prototype.slice.call(arguments)); // CALLBACK function\n\n    var sendTxCallback = function sendTxCallback(err, result) {\n      if (method.handleRevert && !err && isCall && method.isRevertReasonString(result) && method.abiCoder) {\n        var reason = method.abiCoder.decodeParameter('string', '0x' + result.substring(10));\n        var signature = 'Error(String)';\n\n        utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n          reason: reason,\n          signature: signature\n        });\n\n        return;\n      }\n\n      try {\n        result = method.formatOutput(result);\n      } catch (e) {\n        err = e;\n      }\n\n      if (result instanceof Error) {\n        err = result;\n      }\n\n      if (!err) {\n        if (payload.callback) {\n          payload.callback(null, result);\n        }\n      } else {\n        if (err.error) {\n          err = err.error;\n        }\n\n        return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n      } // return PROMISE\n\n\n      if (!isSendTx) {\n        if (!err) {\n          defer.resolve(result);\n        } // return PROMIEVENT\n\n      } else {\n        defer.eventEmitter.emit('transactionHash', result);\n\n        method._confirmTransaction(defer, result, payload);\n      }\n    }; // SENDS the SIGNED SIGNATURE\n\n\n    var sendSignedTx = function sendSignedTx(sign) {\n      var signedPayload = _.extend({}, payload, {\n        method: 'eth_sendRawTransaction',\n        params: [sign.rawTransaction]\n      });\n\n      method.requestManager.send(signedPayload, sendTxCallback);\n    };\n\n    var sendRequest = function sendRequest(payload, method) {\n      if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n        var wallet; // ETH_SENDTRANSACTION\n\n        if (payload.method === 'eth_sendTransaction') {\n          var tx = payload.params[0];\n          wallet = getWallet(_.isObject(tx) ? tx.from : null, method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var txOptions = _.omit(tx, 'from');\n\n            if (method.defaultChain && !txOptions.chain) {\n              txOptions.chain = method.defaultChain;\n            }\n\n            if (method.defaultHardfork && !txOptions.hardfork) {\n              txOptions.hardfork = method.defaultHardfork;\n            }\n\n            if (method.defaultCommon && !txOptions.common) {\n              txOptions.common = method.defaultCommon;\n            }\n\n            return method.accounts.signTransaction(txOptions, wallet.privateKey).then(sendSignedTx).catch(function (err) {\n              if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                defer.eventEmitter.emit('error', err);\n                defer.eventEmitter.removeAllListeners();\n                defer.eventEmitter.catch(function () {});\n              }\n\n              defer.reject(err);\n            });\n          } // ETH_SIGN\n\n        } else if (payload.method === 'eth_sign') {\n          var data = payload.params[1];\n          wallet = getWallet(payload.params[0], method.accounts); // If wallet was found, sign tx, and send using sendRawTransaction\n\n          if (wallet && wallet.privateKey) {\n            var sign = method.accounts.sign(data, wallet.privateKey);\n\n            if (payload.callback) {\n              payload.callback(null, sign.signature);\n            }\n\n            defer.resolve(sign.signature);\n            return;\n          }\n        }\n      }\n\n      return method.requestManager.send(payload, sendTxCallback);\n    }; // Send the actual transaction\n\n\n    if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n      var getGasPrice = new Method({\n        name: 'getGasPrice',\n        call: 'eth_gasPrice',\n        params: 0\n      }).createFunction(method.requestManager);\n      getGasPrice(function (err, gasPrice) {\n        if (gasPrice) {\n          payload.params[0].gasPrice = gasPrice;\n        }\n\n        sendRequest(payload, method);\n      });\n    } else {\n      sendRequest(payload, method);\n    }\n\n    return defer.eventEmitter;\n  }; // necessary to attach things to the method\n\n\n  send.method = method; // necessary for batch requests\n\n  send.request = this.request.bind(this);\n  return send;\n};\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\n\n\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    new Method({\n      name: 'call',\n      call: 'eth_call',\n      params: 2,\n      abiCoder: self.abiCoder,\n      handleRevert: true\n    }).createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber)).then(function () {\n      resolve(false);\n    }).catch(function (error) {\n      if (error.reason) {\n        resolve({\n          reason: error.reason,\n          signature: error.signature\n        });\n      } else {\n        reject(error);\n      }\n    });\n  });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\n\n\nMethod.prototype.isRevertReasonString = function (data) {\n  return _.isString(data) && (data.length - 2) / 2 % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\n\n\nMethod.prototype.request = function () {\n  var payload = this.toPayload(Array.prototype.slice.call(arguments));\n  payload.format = this.formatOutput.bind(this);\n  return payload;\n};\n\nmodule.exports = Method;","map":{"version":3,"names":["_","require","errors","formatters","utils","promiEvent","Subscriptions","subscriptions","Method","options","call","name","Error","params","inputFormatter","outputFormatter","transformPayload","extraFormatters","abiCoder","requestManager","accounts","defaultBlock","defaultAccount","transactionBlockTimeout","transactionConfirmationBlocks","transactionPollingTimeout","defaultCommon","defaultChain","defaultHardfork","handleRevert","prototype","setRequestManager","createFunction","func","buildCall","attachToObject","obj","split","length","getCall","args","isFunction","extractCallback","pop","validateArgs","InvalidNumberOfParams","formatInput","_this","map","formatter","index","formatOutput","result","isArray","res","toPayload","callback","payload","method","_confirmTransaction","defer","promiseResolved","canUnsubscribe","timeoutCount","confirmationCount","intervalId","lastBlock","receiptJSON","gasProvided","isObject","gas","isContractDeployment","data","from","to","hasBytecode","_ethereumCalls","inputBlockNumberFormatter","val","outputBlockFormatter","outputTransactionReceiptFormatter","inputAddressFormatter","inputDefaultBlockNumberFormatter","type","subscriptionName","_ethereumCall","each","mthd","checkConfirmation","existingReceipt","isPolling","err","blockHeader","sub","unsubscribe","clearInterval","resolve","getTransactionReceipt","catch","_fireError","message","eventEmitter","reject","then","receipt","blockHash","receiptFormatter","listeners","undefined","getBlockByNumber","number","block","emit","blockNumber","removeAllListeners","contractAddress","NoContractAddressFoundError","getCode","code","deploymentSuccess","status","contractDeployFormatter","ContractCodeNotStoredError","outOfGas","gasUsed","JSON","stringify","revertMessage","getRevertReason","TransactionRevertInstructionError","reason","signature","TransactionRevertedWithoutReasonError","TransactionOutOfGasError","TransactionError","startWatching","provider","on","subscribe","bind","setInterval","getWallet","wallet","isNumber","address","privateKey","toLowerCase","isSendTx","isCall","send","Array","slice","arguments","sendTxCallback","isRevertReasonString","decodeParameter","substring","RevertInstructionError","e","error","sendSignedTx","sign","signedPayload","extend","rawTransaction","sendRequest","tx","txOptions","omit","chain","hardfork","common","signTransaction","gasPrice","getGasPrice","request","self","Promise","numberToHex","isString","format","module","exports"],"sources":["C:/pr0/blockchain-developer-bootcamp/node_modules/web3/node_modules/web3-core-method/src/index.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\n'use strict';\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar formatters = require('web3-core-helpers').formatters;\nvar utils = require('web3-utils');\nvar promiEvent = require('web3-core-promievent');\nvar Subscriptions = require('web3-core-subscriptions').subscriptions;\n\nvar Method = function Method(options) {\n\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n\n    this.requestManager = options.requestManager;\n\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\n\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n\n};\n\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    func.call = this.call;\n\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n\n    return func;\n};\n\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    func.call = this.call;\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    } else {\n        obj[name[0]] = func;\n    }\n};\n\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return _.isFunction(this.call) ? this.call(args) : this.call;\n};\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n\n    if (!this.inputFormatter) {\n        return args;\n    }\n\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n\n    if (_.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res) : res;\n        });\n    } else {\n        return this.outputFormatter && result ? this.outputFormatter(result) : result;\n    }\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n\n    return payload;\n};\n\n\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this,\n        promiseResolved = false,\n        canUnsubscribe = true,\n        timeoutCount = 0,\n        confirmationCount = 0,\n        intervalId = null,\n        lastBlock = null,\n        receiptJSON = '',\n        gasProvided = (_.isObject(payload.params[0]) && payload.params[0].gas) ? payload.params[0].gas : null,\n        isContractDeployment = _.isObject(payload.params[0]) &&\n            payload.params[0].data &&\n            payload.params[0].from &&\n            !payload.params[0].to,\n        hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                return !!val;\n            }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads', // replace subscription with this name\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _.each(_ethereumCalls, function (mthd) {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n\n\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n            // catch error from requesting receipt\n                .catch(function (err) {\n                    sub.unsubscribe();\n                    promiseResolved = true;\n                    utils._fireError(\n                        {\n                            message: 'Failed to check for transaction receipt:',\n                            data: err\n                        },\n                        defer.eventEmitter,\n                        defer.reject\n                    );\n                })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                    if (!receipt || !receipt.blockHash) {\n                        throw new Error('Receipt missing or blockHash null');\n                    }\n\n                    // apply extra formatters\n                    if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                        receipt = method.extraFormatters.receiptFormatter(receipt);\n                    }\n\n                    // check if confirmation listener exists\n                    if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                        var block;\n\n                        // If there was an immediately retrieved receipt, it's already\n                        // been confirmed by the direct call to checkConfirmation needed\n                        // for parity instant-seal\n                        if (existingReceipt === undefined || confirmationCount !== 0) {\n                            if (isPolling) { // Check if actually a new block is existing on polling\n                                if (lastBlock) {\n                                    block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                    if (block) {\n                                        lastBlock = block;\n                                        defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                                    }\n                                } else {\n                                    block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                                }\n                            } else {\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt);\n                            }\n                        }\n\n                        if ((isPolling && block) || !isPolling) {\n                            confirmationCount++;\n                        }\n                        canUnsubscribe = false;\n\n                        if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                            sub.unsubscribe();\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n\n                    return receipt;\n                })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n\n                    if (isContractDeployment && !promiseResolved) {\n\n                        if (!receipt.contractAddress) {\n\n                            if (canUnsubscribe) {\n                                sub.unsubscribe();\n                                promiseResolved = true;\n                            }\n\n                            utils._fireError(\n                                errors.NoContractAddressFoundError(receipt),\n                                defer.eventEmitter,\n                                defer.reject,\n                                null,\n                                receipt\n                            );\n                            return;\n                        }\n\n                        var code;\n                        try {\n                            code = await _ethereumCall.getCode(receipt.contractAddress);\n                        } catch(err){\n                            // ignore;\n                        }\n\n                        if (!code) {\n                            return;\n                        }\n\n                        // If deployment is status.true and there was a real\n                        // bytecode string, assume it was successful.\n                        var deploymentSuccess = receipt.status === true && hasBytecode;\n\n                        if (deploymentSuccess || code.length > 2) {\n                            defer.eventEmitter.emit('receipt', receipt);\n\n                            // if contract, return instance instead of receipt\n                            if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                                defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                            } else {\n                                defer.resolve(receipt);\n                            }\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            utils._fireError(\n                                errors.ContractCodeNotStoredError(receipt),\n                                defer.eventEmitter,\n                                defer.reject,\n                                null,\n                                receipt\n                            );\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    }\n\n                    return receipt;\n                })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                    if (!isContractDeployment && !promiseResolved) {\n                        if (!receipt.outOfGas &&\n                            (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                            (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                            defer.eventEmitter.emit('receipt', receipt);\n                            defer.resolve(receipt);\n\n                            // need to remove listeners, as they aren't removed automatically when succesfull\n                            if (canUnsubscribe) {\n                                defer.eventEmitter.removeAllListeners();\n                            }\n\n                        } else {\n                            receiptJSON = JSON.stringify(receipt, null, 2);\n\n                            if (receipt.status === false || receipt.status === '0x0') {\n                                try {\n                                    var revertMessage = null;\n\n                                    if (method.handleRevert && method.call === 'eth_sendTransaction') {\n                                        // Get revert reason string with eth_call\n                                        revertMessage = await method.getRevertReason(\n                                            payload.params[0],\n                                            receipt.blockNumber\n                                        );\n\n                                        if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                            utils._fireError(\n                                                errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt),\n                                                defer.eventEmitter,\n                                                defer.reject,\n                                                null,\n                                                receipt\n                                            );\n                                        } else {\n                                            throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                        }\n                                    } else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                } catch (error) {\n                                    // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                    utils._fireError(\n                                        errors.TransactionRevertedWithoutReasonError(receipt),\n                                        defer.eventEmitter,\n                                        defer.reject,\n                                        null,\n                                        receipt\n                                    );\n                                }\n                            } else {\n                                // Throw OOG if status is not existing and provided gas and used gas are equal\n                                utils._fireError(\n                                    errors.TransactionOutOfGasError(receipt),\n                                    defer.eventEmitter,\n                                    defer.reject,\n                                    null,\n                                    receipt\n                                );\n                            }\n                        }\n\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                        }\n                        promiseResolved = true;\n                    }\n\n                })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                    timeoutCount++;\n\n                    // check to see if we are http polling\n                    if (!!isPolling) {\n                        // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                        if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                            utils._fireError(\n                                errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'),\n                                defer.eventEmitter,\n                                defer.reject\n                            );\n                        }\n                    } else {\n                        if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                            utils._fireError(\n                                errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'),\n                                defer.eventEmitter,\n                                defer.reject\n                            );\n                        }\n                    }\n                });\n\n\n        } else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        // if provider allows PUB/SUB\n        if (_.isFunction(this.requestManager.provider.on)) {\n            _ethereumCall.subscribe('newBlockHeaders', checkConfirmation.bind(null, existingReceipt, false));\n        } else {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), 1000);\n        }\n    }.bind(this);\n\n\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n            if (receipt && receipt.blockHash) {\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    // We must keep on watching for new Blocks, if a confirmation listener is present\n                    startWatching(receipt);\n                }\n                checkConfirmation(receipt, false);\n\n            } else if (!promiseResolved) {\n                startWatching();\n            }\n        })\n        .catch(function () {\n            if (!promiseResolved) startWatching();\n        });\n\n};\n\n\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n\n    // is index given\n    if (_.isNumber(from)) {\n        wallet = accounts.wallet[from];\n\n        // is account given\n    } else if (_.isObject(from) && from.address && from.privateKey) {\n        wallet = from;\n\n        // search in wallet for address\n    } else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n\n    return wallet;\n};\n\nMethod.prototype.buildCall = function () {\n    var method = this,\n        isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n        isCall = (method.call === 'eth_call');\n\n    // actual send function\n    var send = function () {\n        var defer = promiEvent(!isSendTx),\n            payload = method.toPayload(Array.prototype.slice.call(arguments));\n\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && !err && isCall && (method.isRevertReasonString(result) && method.abiCoder)) {\n                var reason = method.abiCoder.decodeParameter('string', '0x' + result.substring(10));\n                var signature = 'Error(String)';\n\n                utils._fireError(\n                    errors.RevertInstructionError(reason, signature),\n                    defer.eventEmitter,\n                    defer.reject,\n                    payload.callback,\n                    {\n                        reason: reason,\n                        signature: signature\n                    }\n                );\n\n                return;\n            }\n\n            try {\n                result = method.formatOutput(result);\n            } catch (e) {\n                err = e;\n            }\n\n            if (result instanceof Error) {\n                err = result;\n            }\n\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            } else {\n                if (err.error) {\n                    err = err.error;\n                }\n\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n\n                // return PROMIEVENT\n            } else {\n                defer.eventEmitter.emit('transactionHash', result);\n\n                method._confirmTransaction(defer, result, payload);\n            }\n\n        };\n\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n\n            var signedPayload = _.extend({}, payload, {\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            });\n\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n\n\n        var sendRequest = function (payload, method) {\n\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((_.isObject(tx)) ? tx.from : null, method.accounts);\n\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var txOptions = _.omit(tx, 'from');\n\n                        if (method.defaultChain && !txOptions.chain) {\n                            txOptions.chain = method.defaultChain;\n                        }\n\n                        if (method.defaultHardfork && !txOptions.hardfork) {\n                            txOptions.hardfork = method.defaultHardfork;\n                        }\n\n                        if (method.defaultCommon && !txOptions.common) {\n                            txOptions.common = method.defaultCommon;\n                        }\n\n                        return method.accounts.signTransaction(txOptions, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                                if (_.isFunction(defer.eventEmitter.listeners) && defer.eventEmitter.listeners('error').length) {\n                                    defer.eventEmitter.emit('error', err);\n                                    defer.eventEmitter.removeAllListeners();\n                                    defer.eventEmitter.catch(function () {\n                                    });\n                                }\n                                defer.reject(err);\n                            });\n                    }\n\n                    // ETH_SIGN\n                } else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n\n\n                }\n            }\n\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n\n        // Send the actual transaction\n        if (isSendTx && _.isObject(payload.params[0]) && typeof payload.params[0].gasPrice === 'undefined') {\n\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n\n            getGasPrice(function (err, gasPrice) {\n\n                if (gasPrice) {\n                    payload.params[0].gasPrice = gasPrice;\n                }\n                sendRequest(payload, method);\n            });\n\n        } else {\n            sendRequest(payload, method);\n        }\n\n\n        return defer.eventEmitter;\n    };\n\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\n\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n                resolve(false);\n            })\n            .catch(function (error) {\n                if (error.reason) {\n                    resolve({\n                        reason: error.reason,\n                        signature: error.signature\n                    });\n                } else {\n                    reject(error);\n                }\n            });\n    });\n};\n\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return _.isString(data) && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\n\nmodule.exports = Method;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}